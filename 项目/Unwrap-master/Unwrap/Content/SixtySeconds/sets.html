<p>Sets are collections of values just like arrays, except they have two differences:</p>
<ol>
<li>Items aren’t stored in any order; they are stored in what is effectively a random order.</li>
<li>No item can appear twice in a set; all items must be unique.</li>
</ol>
<p>You can create sets directly from arrays, like this:</p>
<pre class="code">
<p></p>
<p><span class="keyword">let</span> colors <span class="operator">=</span> <span class="function">Set</span><span class="punctuation">(</span><span class="punctuation">[</span><span class="string">"red"</span><span class="punctuation">,</span> <span class="string">"green"</span><span class="punctuation">,</span> <span class="string">"blue"</span><span class="punctuation">]</span><span class="punctuation">)</span></p>
<p></p>
</pre>

<p style="height: 0px; margin-bottom: 0px;"></p>
<p>When you look at the value of <code>colors</code> inside the playground output you’ll see it doesn’t match the order we used to create it. It’s not really a <em>random</em> order, it’s just <em>unordered</em> – Swift makes no guarantees about its order. Because they are unordered, you can’t read values from a set using numerical positions like you can with arrays.</p>
<p>If you try to insert a duplicate item into a set, the duplicates get ignored. For example:</p>
<pre class="code">
<p></p>
<p><span class="keyword">let</span> colors2 <span class="operator">=</span> <span class="function">Set</span><span class="punctuation">(</span><span class="punctuation">[</span><span class="string">"red"</span><span class="punctuation">,</span> <span class="string">"green"</span><span class="punctuation">,</span> <span class="string">"blue"</span><span class="punctuation">,</span> <span class="string">"red"</span><span class="punctuation">,</span> <span class="string">"blue"</span><span class="punctuation">]</span><span class="punctuation">)</span></p>
<p></p>
</pre>

<p style="height: 0px; margin-bottom: 0px;"></p>
<p>The final <code>colors2</code> set will still only include red, green, and blue once.</p>